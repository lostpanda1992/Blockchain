采用计算电路的计算模型，而不是 CPU 加内存的模型。算术电路计算模型和计算机 CPU 跑程序的表达能力是大致相当的，基本上常见的计算都可以表达
算术电路由一些互相连接的「门」组成，有「乘法门」与 「加法门」。输入从电路的左边输入，运算完右边的输出线上产生运行结果，整个过程就是在算「+」、「×」
刚才算术电路中所有乘法门的左输入门、右输入门、输出门做三个不同的多项式编码，形成三根曲线
现在只要有三根曲线，验证这三根曲线（三个多项式）之间满足乘法关系就够了。
验证乘法关系只需要随机抽样 X 轴上的一个点均可，不需要再验证一百亿个门。虽然验证了这三根曲线，但显然验证者看到了太多的秘密，零知识证明要保证计算过程的秘密不被泄漏。

验证每一个门的运算，对于每一个加法门，验证左输入和右输入加起来等不等于输出。
对于乘法门，验证左输入和右输入乘起来等不等于输出。只要耐心地挨个检查每一个门，肯定就没问题。
有没有一种办法把这幺多门的验证过程变的简单？用「多项式编码」这个数学工具可以做到这一点。

可以把多项式运算同态映射到椭圆曲线群上。
整数有限域的加法运算会映射到椭圆曲线群上的二元运算
整数乘法运算可以同态映射到椭圆曲线群上的双线性配对（Pairing）操作，乘法只能是单乘法，但足可以验证算术电路的运算关系。

一个有限域，首先是一个包含有限个元素的集合。有限域的一个例子是模p的整数集，其中p是素数
在域中，我们有两种二元运算：加法(+)和乘法(·)。它们都具有封闭性，结合律和交换律
对于这两种运算，每个元素都存在一个唯一的单位元，并且每个元素都存在一个唯一的逆元
模p除法：x/y等于x乘以y的乘法逆元 它给了我们一个基本的除法：找到该数的乘法逆元，然后进行乘法运算。
用扩展的欧几里德算法（extended Euclidean algorithm）可以“轻松”计算乘法逆元

我们可以将椭圆曲线定义在 Fp上。在上一篇文章中我们定义了实数域上的椭圆曲线
之前实数域上的连续曲线现在转变为xy平面上的一组不相交的点的集合。但是我们可以证明，即使我们限制了定域，Fp 中的椭圆曲线（的点集）仍然是一个阿贝尔群。
阿贝尔群:它由自身的集合 G 和二元运算 * 构成。它除了满足一般的群公理，即运算的结合律、G 有单位元、所有 G 的元素都有逆元之外，还满足交换律公理。因为阿贝尔群的群运算满足交换律和结合律，群元素乘积的值与乘法运算时的次序无关。

想表达任何计算的时候，先用高级语言编写代码，然后通过 compiler 编译成算术电路，再通过矩阵表示产生 R1CS 矩阵，并通过多项式编码产生 QAP，
最后通过 Trusted-Setup 产生：Proving Key、Verifying Key。用 Proving Key 可以证明计算过程，而通过 Verifying Key 就可以知道证明π是对的。

对大型数字向量（字段或组元素）的乘法，特别是可变基数和固定基数多标量乘法（MSM）；或者，

快速傅里叶变换(FFT) 和逆 FFT（尽管有 用于无 FFT 证明系统的 技术）。

在同时存在 FFT 和 MSM 的系统中，大约 70% 的时间生成证明花费在 MSM 上，其余时间则由 FFT 主导。



















